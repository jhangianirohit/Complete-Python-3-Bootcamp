<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FX Option P&L Calculator - Multi-Strike</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1600px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        h2 {
            color: #555;
            margin-top: 30px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
        }
        .input-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .input-group {
            display: flex;
            flex-direction: column;
        }
        label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #555;
        }
        input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        button {
            background-color: #007bff;
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 20px;
        }
        button:hover {
            background-color: #0056b3;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 12px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px 6px;
            text-align: right;
        }
        th {
            background-color: #007bff;
            color: white;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .summary-table tr:first-child {
            background-color: #fff;
        }
        .summary-table tbody tr:last-child {
            background-color: #d4edda;
            font-weight: bold;
        }
        .strike-table tbody tr:first-child {
            background-color: #fff3cd;
        }
        .strike-table tbody tr:last-child {
            background-color: #d4edda;
            font-weight: bold;
        }
        .verification {
            margin-top: 20px;
            padding: 15px;
            background-color: #d4edda;
            border-left: 4px solid #28a745;
            border-radius: 4px;
            font-size: 13px;
        }
        .warning {
            background-color: #fff3cd;
            border-left-color: #ffc107;
        }
        .info-box {
            background-color: #e7f3ff;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            border-left: 4px solid #007bff;
        }
        .strike-section {
            margin-top: 30px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
        .strike-header {
            font-size: 16px;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>FX Option P&L Calculator - Multi-Strike Delta Hedging</h1>

        <div class="info-box">
            <strong>Configuration:</strong> EURUSD Options (5 strikes), Notional: 100M USD per strike, Hedge Frequency: Every 6 hours
            <br><strong>Model:</strong> Black-Scholes with r=0, q=0
            <br><strong>Strikes:</strong> 10Δ Put, 25Δ Put, ATM Call, 25Δ Call, 10Δ Call
        </div>

        <div class="input-section">
            <div class="input-group">
                <label>Initial Spot (t=0h):</label>
                <input type="number" id="spot0" step="0.0001" value="1.1000">
            </div>
            <div class="input-group">
                <label>Implied Volatility (%):</label>
                <input type="number" id="vol" step="0.1" value="10">
            </div>
        </div>

        <div class="input-section">
            <div class="input-group">
                <label>Spot at t=6h:</label>
                <input type="number" id="spot6" step="0.0001" value="1.1050">
            </div>
            <div class="input-group">
                <label>Spot at t=12h:</label>
                <input type="number" id="spot12" step="0.0001" value="1.1100">
            </div>
            <div class="input-group">
                <label>Spot at t=18h:</label>
                <input type="number" id="spot18" step="0.0001" value="1.1150">
            </div>
            <div class="input-group">
                <label>Spot at t=24h:</label>
                <input type="number" id="spot24" step="0.0001" value="1.1200">
            </div>
        </div>

        <button onclick="calculate()">Calculate All Strikes</button>

        <div id="strikes-info"></div>
        <div id="summary"></div>
        <div id="results"></div>
    </div>

    <script>
        // Constants
        const NOTIONAL = 100_000_000; // 100 million USD
        const HOURS_PER_YEAR = 365 * 24;

        /**
         * Standard normal cumulative distribution function
         */
        function normCDF(x) {
            const t = 1 / (1 + 0.2316419 * Math.abs(x));
            const d = 0.3989423 * Math.exp(-x * x / 2);
            const prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
            return x > 0 ? 1 - prob : prob;
        }

        /**
         * Black-Scholes Call Option Price
         */
        function blackScholesCall(S, K, T, sigma) {
            if (T <= 0) {
                return Math.max(S - K, 0);
            }

            const sqrtT = Math.sqrt(T);
            const d1 = (Math.log(S / K) + (0.5 * sigma * sigma * T)) / (sigma * sqrtT);
            const d2 = d1 - sigma * sqrtT;

            return S * normCDF(d1) - K * normCDF(d2);
        }

        /**
         * Black-Scholes Put Option Price
         */
        function blackScholesPut(S, K, T, sigma) {
            if (T <= 0) {
                return Math.max(K - S, 0);
            }

            const sqrtT = Math.sqrt(T);
            const d1 = (Math.log(S / K) + (0.5 * sigma * sigma * T)) / (sigma * sqrtT);
            const d2 = d1 - sigma * sqrtT;

            return K * normCDF(-d2) - S * normCDF(-d1);
        }

        /**
         * Delta of a Call Option
         */
        function callDelta(S, K, T, sigma) {
            if (T <= 0) {
                return S > K ? 1 : 0;
            }

            const sqrtT = Math.sqrt(T);
            const d1 = (Math.log(S / K) + (0.5 * sigma * sigma * T)) / (sigma * sqrtT);

            return normCDF(d1);
        }

        /**
         * Delta of a Put Option
         */
        function putDelta(S, K, T, sigma) {
            return callDelta(S, K, T, sigma) - 1;
        }

        /**
         * Solve for strike given target delta using bisection method
         * @param {number} S - Spot price
         * @param {number} T - Time to expiry in years
         * @param {number} sigma - Volatility
         * @param {number} targetDelta - Target delta value
         * @param {string} optionType - 'call' or 'put'
         */
        function solveStrikeForDelta(S, T, sigma, targetDelta, optionType) {
            // Search bounds: 50% to 150% of spot
            let kLow = S * 0.5;
            let kHigh = S * 1.5;

            const tolerance = 0.00001;
            const maxIterations = 100;

            for (let i = 0; i < maxIterations; i++) {
                const kMid = (kLow + kHigh) / 2;
                const delta = optionType === 'call' ? callDelta(S, kMid, T, sigma) : putDelta(S, kMid, T, sigma);

                if (Math.abs(delta - targetDelta) < tolerance) {
                    return kMid;
                }

                // For calls: higher strike = lower delta
                // For puts: higher strike = more negative delta (lower in absolute value)
                if (optionType === 'call') {
                    if (delta > targetDelta) {
                        kLow = kMid;  // Need higher strike to reduce delta
                    } else {
                        kHigh = kMid;  // Need lower strike to increase delta
                    }
                } else {
                    if (delta < targetDelta) {  // delta is more negative than target
                        kLow = kMid;  // Need higher strike to make delta less negative
                    } else {
                        kHigh = kMid;  // Need lower strike to make delta more negative
                    }
                }
            }

            return (kLow + kHigh) / 2;
        }

        /**
         * Format number as currency (thousands with comma separators)
         */
        function formatThousand(value) {
            const thousands = value / 1_000;
            const absThousands = Math.abs(thousands);
            const sign = thousands < 0 ? '-' : '';
            const formatted = absThousands.toFixed(1).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            return sign + formatted + 'k';
        }

        /**
         * Format number as millions with one decimal
         */
        function formatMillion(value) {
            const millions = value / 1_000_000;
            const absMillion = Math.abs(millions);
            const sign = millions < 0 ? '-' : '';
            const formatted = absMillion.toFixed(1);
            return sign + formatted + 'm';
        }

        /**
         * Format number with specified decimals
         */
        function formatNumber(value, decimals = 4) {
            return value.toFixed(decimals);
        }

        /**
         * Calculate P&L for a single strike
         */
        function calculateStrike(spots, strike, timeInYears, sigma, optionType) {
            let results = [];
            let cumulativeHedge = 0;
            let weightedSumHedge = 0;
            let avgSpot = 0;
            let realizedPnL = 0;
            let previousDelta = 0;

            const times = [0, 6, 12, 18, 24];

            // Calculate premium at t=0
            const premium = optionType === 'call'
                ? blackScholesCall(spots[0], strike, timeInYears[0], sigma)
                : blackScholesPut(spots[0], strike, timeInYears[0], sigma);
            const premiumPaid = -premium * NOTIONAL;

            for (let i = 0; i < times.length; i++) {
                const t = times[i];
                const spot = spots[i];
                const T = timeInYears[i];

                // Calculate option value and delta
                const optionValue = optionType === 'call'
                    ? blackScholesCall(spot, strike, T, sigma)
                    : blackScholesPut(spot, strike, T, sigma);

                const delta = optionType === 'call'
                    ? callDelta(spot, strike, T, sigma)
                    : putDelta(spot, strike, T, sigma);

                // Calculate incremental hedge
                let incrementalHedge;
                if (i === 0) {
                    incrementalHedge = -delta * NOTIONAL;
                } else {
                    const deltaChange = delta - previousDelta;
                    incrementalHedge = -deltaChange * NOTIONAL;
                }

                // Update cumulative hedge with realized/unrealized P&L tracking
                const prevCumHedge = cumulativeHedge;
                const prevAvgSpot = avgSpot;
                const newCumHedge = prevCumHedge + incrementalHedge;

                if (prevCumHedge === 0) {
                    cumulativeHedge = newCumHedge;
                    weightedSumHedge = newCumHedge * spot;
                    avgSpot = spot;
                } else if (newCumHedge === 0) {
                    realizedPnL += prevCumHedge * (spot - prevAvgSpot);
                    cumulativeHedge = 0;
                    weightedSumHedge = 0;
                    avgSpot = 0;
                } else if (Math.sign(prevCumHedge) !== Math.sign(newCumHedge)) {
                    realizedPnL += prevCumHedge * (spot - prevAvgSpot);
                    cumulativeHedge = newCumHedge;
                    weightedSumHedge = newCumHedge * spot;
                    avgSpot = spot;
                } else if (Math.abs(newCumHedge) < Math.abs(prevCumHedge)) {
                    const closedAmount = prevCumHedge - newCumHedge;
                    realizedPnL += closedAmount * (spot - prevAvgSpot);
                    cumulativeHedge = newCumHedge;
                    weightedSumHedge = newCumHedge * prevAvgSpot;
                    avgSpot = prevAvgSpot;
                } else {
                    cumulativeHedge = newCumHedge;
                    weightedSumHedge += incrementalHedge * spot;
                    avgSpot = weightedSumHedge / cumulativeHedge;
                }

                const unrealizedPnL = cumulativeHedge !== 0 ? cumulativeHedge * (spot - avgSpot) : 0;
                const hedgePnL = realizedPnL + unrealizedPnL;
                const portfolioValue = premiumPaid + (optionValue * NOTIONAL) + hedgePnL;

                results.push({
                    time: t,
                    spot: spot,
                    delta: delta,
                    incrementalHedge: incrementalHedge,
                    cumulativeHedge: cumulativeHedge,
                    avgSpot: avgSpot,
                    realizedPnL: realizedPnL,
                    unrealizedPnL: unrealizedPnL,
                    hedgePnL: hedgePnL,
                    optionValue: optionValue * NOTIONAL,
                    premium: premiumPaid,
                    portfolioValue: portfolioValue
                });

                previousDelta = delta;
            }

            return results;
        }

        /**
         * Main calculation function
         */
        function calculate() {
            // Get inputs
            const spots = [
                parseFloat(document.getElementById('spot0').value),
                parseFloat(document.getElementById('spot6').value),
                parseFloat(document.getElementById('spot12').value),
                parseFloat(document.getElementById('spot18').value),
                parseFloat(document.getElementById('spot24').value)
            ];
            const volPercent = parseFloat(document.getElementById('vol').value);
            const sigma = volPercent / 100;

            const times = [0, 6, 12, 18, 24];
            const timeInYears = times.map(h => (24 - h) / HOURS_PER_YEAR);

            // Calculate strikes for each delta target
            const S0 = spots[0];
            const T0 = timeInYears[0];

            const strikes = [
                { name: '10Δ Put', strike: solveStrikeForDelta(S0, T0, sigma, -0.10, 'put'), type: 'put' },
                { name: '25Δ Put', strike: solveStrikeForDelta(S0, T0, sigma, -0.25, 'put'), type: 'put' },
                { name: 'ATM Call', strike: S0, type: 'call' },
                { name: '25Δ Call', strike: solveStrikeForDelta(S0, T0, sigma, 0.75, 'call'), type: 'call' },
                { name: '10Δ Call', strike: solveStrikeForDelta(S0, T0, sigma, 0.90, 'call'), type: 'call' }
            ];

            // Calculate P&L for each strike
            const allResults = strikes.map(s => ({
                name: s.name,
                strike: s.strike,
                type: s.type,
                results: calculateStrike(spots, s.strike, timeInYears, sigma, s.type)
            }));

            // Display results
            displayResults(allResults, strikes);
        }

        /**
         * Display results
         */
        function displayResults(allResults, strikes) {
            // Display calculated strikes
            let strikesHTML = '<div class="verification"><strong>Calculated Strikes:</strong><br>';
            strikes.forEach(s => {
                strikesHTML += `${s.name}: ${formatNumber(s.strike)} | `;
            });
            strikesHTML += '</div>';
            document.getElementById('strikes-info').innerHTML = strikesHTML;

            // Create summary table
            let summaryHTML = '<h2>Summary - Final P&L Across All Strikes</h2>';
            summaryHTML += '<table class="summary-table"><thead><tr>';
            summaryHTML += '<th>Strike Type</th><th>Strike Price</th><th>Final Portfolio P&L</th></tr></thead><tbody>';

            let totalPnL = 0;
            allResults.forEach(r => {
                const finalPnL = r.results[r.results.length - 1].portfolioValue;
                totalPnL += finalPnL;
                summaryHTML += `<tr><td>${r.name}</td><td>${formatNumber(r.strike)}</td><td>${formatThousand(finalPnL)}</td></tr>`;
            });

            summaryHTML += `<tr><td colspan="2"><strong>TOTAL</strong></td><td><strong>${formatThousand(totalPnL)}</strong></td></tr>`;
            summaryHTML += '</tbody></table>';

            document.getElementById('summary').innerHTML = summaryHTML;

            // Create individual tables for each strike
            let resultsHTML = '';

            allResults.forEach(strikeData => {
                resultsHTML += `<div class="strike-section">`;
                resultsHTML += `<div class="strike-header">Strike: ${formatNumber(strikeData.strike)} (${strikeData.name})</div>`;

                // Verification at t=0
                const t0Portfolio = strikeData.results[0].portfolioValue;
                const isValid = Math.abs(t0Portfolio) < 1;
                resultsHTML += `<div class="verification ${isValid ? '' : 'warning'}" style="font-size: 11px; padding: 8px;">`;
                resultsHTML += `<strong>t=0 Verification:</strong> Portfolio = ${formatThousand(t0Portfolio)} `;
                resultsHTML += isValid ? '✓' : '✗ ERROR';
                resultsHTML += '</div>';

                // Table
                resultsHTML += '<table class="strike-table"><thead><tr>';
                resultsHTML += '<th>Time (h)</th><th>Spot</th><th>Delta</th>';
                resultsHTML += '<th>Incr Hedge</th><th>Cum Hedge</th><th>Avg Spot</th>';
                resultsHTML += '<th>Hedge P&L</th><th>Option Value</th><th>Premium</th><th>Portfolio Value</th>';
                resultsHTML += '</tr></thead><tbody>';

                strikeData.results.forEach(r => {
                    resultsHTML += '<tr>';
                    resultsHTML += `<td>${r.time}</td>`;
                    resultsHTML += `<td>${formatNumber(r.spot)}</td>`;
                    resultsHTML += `<td>${formatNumber(r.delta, 3)}</td>`;
                    resultsHTML += `<td>${formatMillion(r.incrementalHedge)}</td>`;
                    resultsHTML += `<td>${formatMillion(r.cumulativeHedge)}</td>`;
                    resultsHTML += `<td>${r.avgSpot !== 0 ? formatNumber(r.avgSpot) : '-'}</td>`;
                    resultsHTML += `<td>${formatThousand(r.hedgePnL)}</td>`;
                    resultsHTML += `<td>${formatThousand(r.optionValue)}</td>`;
                    resultsHTML += `<td>${formatThousand(r.premium)}</td>`;
                    resultsHTML += `<td>${formatThousand(r.portfolioValue)}</td>`;
                    resultsHTML += '</tr>';
                });

                resultsHTML += '</tbody></table></div>';
            });

            document.getElementById('results').innerHTML = resultsHTML;
        }

        // Calculate on page load
        window.onload = calculate;
    </script>
</body>
</html>
