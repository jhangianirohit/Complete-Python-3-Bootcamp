<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FX Option P&L Calculator - Multi-Strike</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1600px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        h2 {
            color: #555;
            margin-top: 30px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
        }
        .input-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .input-group {
            display: flex;
            flex-direction: column;
        }
        label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #555;
        }
        input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        button {
            background-color: #007bff;
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 20px;
        }
        button:hover {
            background-color: #0056b3;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 12px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px 6px;
            text-align: right;
        }
        th {
            background-color: #007bff;
            color: white;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .summary-table tr:first-child {
            background-color: #fff;
        }
        .summary-table tbody tr:last-child {
            background-color: #d4edda;
            font-weight: bold;
        }
        .strike-table tbody tr:first-child {
            background-color: #fff3cd;
        }
        .strike-table tbody tr:last-child {
            background-color: #d4edda;
            font-weight: bold;
        }
        .verification {
            margin-top: 20px;
            padding: 15px;
            background-color: #d4edda;
            border-left: 4px solid #28a745;
            border-radius: 4px;
            font-size: 13px;
        }
        .warning {
            background-color: #fff3cd;
            border-left-color: #ffc107;
        }
        .info-box {
            background-color: #e7f3ff;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            border-left: 4px solid #007bff;
        }
        .strike-section {
            margin-top: 30px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
        .strike-header {
            font-size: 16px;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>FX Option P&L Calculator - Multi-Strike Delta Hedging</h1>

        <div class="info-box">
            <strong>Configuration:</strong> EURUSD Options (5 strikes), Notional: 100M USD per strike, Hedge Frequency: Every 6 hours
            <br><strong>Model:</strong> Black-Scholes with r=0, q=0
            <br><strong>Strikes:</strong> 10Δ Put, 25Δ Put, ATM Call, 25Δ Call, 10Δ Call
        </div>

        <div class="input-section">
            <div class="input-group">
                <label>Initial Spot (t=0h):</label>
                <input type="number" id="spot0" step="0.0001" value="1.1000">
            </div>
            <div class="input-group">
                <label>Implied Volatility (%):</label>
                <input type="number" id="vol" step="0.1" value="10">
            </div>
        </div>

        <div class="input-section">
            <div class="input-group">
                <label>Spot at t=6h:</label>
                <input type="number" id="spot6" step="0.0001" value="1.1050">
            </div>
            <div class="input-group">
                <label>Spot at t=12h:</label>
                <input type="number" id="spot12" step="0.0001" value="1.1100">
            </div>
            <div class="input-group">
                <label>Spot at t=18h:</label>
                <input type="number" id="spot18" step="0.0001" value="1.1150">
            </div>
            <div class="input-group">
                <label>Spot at t=24h:</label>
                <input type="number" id="spot24" step="0.0001" value="1.1200">
            </div>
        </div>

        <button onclick="calculate()">Calculate All Strikes</button>

        <div id="strikes-info"></div>
        <div id="summary"></div>
        <div id="results"></div>
    </div>

    <script>
        // Constants
        const NOTIONAL = 100_000_000; // 100 million USD
        const HOURS_PER_YEAR = 365 * 24;

        /**
         * Standard normal cumulative distribution function
         */
        function normCDF(x) {
            const t = 1 / (1 + 0.2316419 * Math.abs(x));
            const d = 0.3989423 * Math.exp(-x * x / 2);
            const prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
            return x > 0 ? 1 - prob : prob;
        }

        /**
         * Inverse of standard normal cumulative distribution function
         * Uses Beasley-Springer-Moro algorithm
         * @param {number} p - Probability (0 < p < 1)
         * @returns {number} z such that N(z) = p
         */
        function normInv(p) {
            const a = [2.50662823884, -18.61500062529, 41.39119773534, -25.44106049637];
            const b = [-8.47351093090, 23.08336743743, -21.06224101826, 3.13082909833];
            const c = [0.3374754822726147, 0.9761690190917186, 0.1607979714918209,
                       0.0276438810333863, 0.0038405729373609, 0.0003951896511919,
                       0.0000321767881768, 0.0000002888167364, 0.0000003960315187];

            if (p <= 0 || p >= 1) {
                throw new Error("Probability must be between 0 and 1");
            }

            const y = p - 0.5;

            if (Math.abs(y) < 0.42) {
                // Central region
                const r = y * y;
                let num = a[3];
                let den = 1.0;

                for (let i = 2; i >= 0; i--) {
                    num = num * r + a[i];
                }
                for (let i = 3; i >= 0; i--) {
                    den = den * r + b[i];
                }

                return y * num / den;
            } else {
                // Tail region
                let r = p < 0.5 ? p : 1 - p;
                r = Math.sqrt(-Math.log(r));

                let num = c[8];
                for (let i = 7; i >= 0; i--) {
                    num = num * r + c[i];
                }

                const z = num / r;
                return p < 0.5 ? -z : z;
            }
        }

        /**
         * Black-Scholes Call Option Price
         */
        function blackScholesCall(S, K, T, sigma) {
            if (T <= 0) {
                return Math.max(S - K, 0);
            }

            const sqrtT = Math.sqrt(T);
            const d1 = (Math.log(S / K) + (0.5 * sigma * sigma * T)) / (sigma * sqrtT);
            const d2 = d1 - sigma * sqrtT;

            return S * normCDF(d1) - K * normCDF(d2);
        }

        /**
         * Black-Scholes Put Option Price
         */
        function blackScholesPut(S, K, T, sigma) {
            if (T <= 0) {
                return Math.max(K - S, 0);
            }

            const sqrtT = Math.sqrt(T);
            const d1 = (Math.log(S / K) + (0.5 * sigma * sigma * T)) / (sigma * sqrtT);
            const d2 = d1 - sigma * sqrtT;

            return K * normCDF(-d2) - S * normCDF(-d1);
        }

        /**
         * Delta of a Call Option
         */
        function callDelta(S, K, T, sigma) {
            if (T <= 0) {
                return S > K ? 1 : 0;
            }

            const sqrtT = Math.sqrt(T);
            const d1 = (Math.log(S / K) + (0.5 * sigma * sigma * T)) / (sigma * sqrtT);

            return normCDF(d1);
        }

        /**
         * Delta of a Put Option
         */
        function putDelta(S, K, T, sigma) {
            return callDelta(S, K, T, sigma) - 1;
        }

        /**
         * Calculate strike for target delta using DIRECT closed-form formula
         * @param {number} spot - Spot price (e.g., 1.1000)
         * @param {number} annualizedVol - Annual volatility (e.g., 0.10 for 10%)
         * @param {number} timeInYears - Time to expiry in years (e.g., 1/365 for 1-day)
         * @param {number} targetDelta - Target delta value
         *   For puts: negative (e.g., -0.25, -0.10)
         *   For calls: positive (e.g., +0.25, +0.10)
         * @returns {number} Strike price that produces the target delta
         *
         * Example (spot=1.1000, vol=10%, time=1/365):
         *   10Δ Put:  K = 1.0926 (below spot) ✓
         *   25Δ Put:  K = 1.0961 (below spot) ✓
         *   25Δ Call: K = 1.1039 (above spot) ✓
         *   10Δ Call: K = 1.1074 (above spot) ✓
         */
        function calculateStrike(spot, annualizedVol, timeInYears, targetDelta) {
            // Step 1: Calculate vol adjusted for time
            const volSqrtT = annualizedVol * Math.sqrt(timeInYears);

            // Step 2: Convert delta to d1
            // For puts (negative delta), we need N(d1) = delta + 1
            // For calls (positive delta), we need N(d1) = delta
            const d1Input = (targetDelta < 0) ? (targetDelta + 1.0) : targetDelta;
            const d1 = normInv(d1Input);

            // Step 3: Calculate strike
            const logMoneyness = d1 * volSqrtT - 0.5 * annualizedVol * annualizedVol * timeInYears;
            const strike = spot * Math.exp(-logMoneyness);

            return strike;
        }

        /**
         * Format number as currency (thousands with comma separators)
         */
        function formatThousand(value) {
            const thousands = value / 1_000;
            const absThousands = Math.abs(thousands);
            const sign = thousands < 0 ? '-' : '';
            const formatted = absThousands.toFixed(1).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            return sign + formatted + 'k';
        }

        /**
         * Format number as millions with one decimal
         */
        function formatMillion(value) {
            const millions = value / 1_000_000;
            const absMillion = Math.abs(millions);
            const sign = millions < 0 ? '-' : '';
            const formatted = absMillion.toFixed(1);
            return sign + formatted + 'm';
        }

        /**
         * Format number with specified decimals
         */
        function formatNumber(value, decimals = 4) {
            return value.toFixed(decimals);
        }

        /**
         * Calculate P&L for a single strike
         */
        function calculateStrikePnL(spots, strike, timeInYears, sigma, optionType) {
            let results = [];
            let cumulativeHedge = 0;
            let weightedSumHedge = 0;
            let avgSpot = 0;
            let realizedPnL = 0;
            let previousDelta = 0;

            const times = [0, 6, 12, 18, 24];

            // Calculate premium at t=0
            const premium = optionType === 'call'
                ? blackScholesCall(spots[0], strike, timeInYears[0], sigma)
                : blackScholesPut(spots[0], strike, timeInYears[0], sigma);
            const premiumPaid = -premium * NOTIONAL;

            for (let i = 0; i < times.length; i++) {
                const t = times[i];
                const spot = spots[i];
                const T = timeInYears[i];

                // Calculate option value and delta
                const optionValue = optionType === 'call'
                    ? blackScholesCall(spot, strike, T, sigma)
                    : blackScholesPut(spot, strike, T, sigma);

                const delta = optionType === 'call'
                    ? callDelta(spot, strike, T, sigma)
                    : putDelta(spot, strike, T, sigma);

                // Calculate incremental hedge
                let incrementalHedge;
                if (i === 0) {
                    incrementalHedge = -delta * NOTIONAL;
                } else {
                    const deltaChange = delta - previousDelta;
                    incrementalHedge = -deltaChange * NOTIONAL;
                }

                // Update cumulative hedge with realized/unrealized P&L tracking
                const prevCumHedge = cumulativeHedge;
                const prevAvgSpot = avgSpot;
                const newCumHedge = prevCumHedge + incrementalHedge;

                if (prevCumHedge === 0) {
                    cumulativeHedge = newCumHedge;
                    weightedSumHedge = newCumHedge * spot;
                    avgSpot = spot;
                } else if (newCumHedge === 0) {
                    realizedPnL += prevCumHedge * (spot - prevAvgSpot);
                    cumulativeHedge = 0;
                    weightedSumHedge = 0;
                    avgSpot = 0;
                } else if (Math.sign(prevCumHedge) !== Math.sign(newCumHedge)) {
                    realizedPnL += prevCumHedge * (spot - prevAvgSpot);
                    cumulativeHedge = newCumHedge;
                    weightedSumHedge = newCumHedge * spot;
                    avgSpot = spot;
                } else if (Math.abs(newCumHedge) < Math.abs(prevCumHedge)) {
                    const closedAmount = prevCumHedge - newCumHedge;
                    realizedPnL += closedAmount * (spot - prevAvgSpot);
                    cumulativeHedge = newCumHedge;
                    weightedSumHedge = newCumHedge * prevAvgSpot;
                    avgSpot = prevAvgSpot;
                } else {
                    cumulativeHedge = newCumHedge;
                    weightedSumHedge += incrementalHedge * spot;
                    avgSpot = weightedSumHedge / cumulativeHedge;
                }

                const unrealizedPnL = cumulativeHedge !== 0 ? cumulativeHedge * (spot - avgSpot) : 0;
                const hedgePnL = realizedPnL + unrealizedPnL;
                const portfolioValue = premiumPaid + (optionValue * NOTIONAL) + hedgePnL;

                results.push({
                    time: t,
                    spot: spot,
                    delta: delta,
                    incrementalHedge: incrementalHedge,
                    cumulativeHedge: cumulativeHedge,
                    avgSpot: avgSpot,
                    realizedPnL: realizedPnL,
                    unrealizedPnL: unrealizedPnL,
                    hedgePnL: hedgePnL,
                    optionValue: optionValue * NOTIONAL,
                    premium: premiumPaid,
                    portfolioValue: portfolioValue
                });

                previousDelta = delta;
            }

            return results;
        }

        /**
         * Main calculation function
         */
        function calculate() {
            // Get inputs
            const spots = [
                parseFloat(document.getElementById('spot0').value),
                parseFloat(document.getElementById('spot6').value),
                parseFloat(document.getElementById('spot12').value),
                parseFloat(document.getElementById('spot18').value),
                parseFloat(document.getElementById('spot24').value)
            ];
            const volPercent = parseFloat(document.getElementById('vol').value);
            const sigma = volPercent / 100;

            const times = [0, 6, 12, 18, 24];
            const timeInYears = times.map(h => (24 - h) / HOURS_PER_YEAR);

            // Calculate strikes for each delta target
            const S0 = spots[0];
            const T0 = timeInYears[0];

            const strikes = [
                { name: '10Δ Put', strike: calculateStrike(S0, sigma, T0, -0.10), type: 'put' },
                { name: '25Δ Put', strike: calculateStrike(S0, sigma, T0, -0.25), type: 'put' },
                { name: 'ATM Call', strike: S0, type: 'call' },
                { name: '25Δ Call', strike: calculateStrike(S0, sigma, T0, 0.25), type: 'call' },
                { name: '10Δ Call', strike: calculateStrike(S0, sigma, T0, 0.10), type: 'call' }
            ];

            // Calculate P&L for each strike
            const allResults = strikes.map(s => ({
                name: s.name,
                strike: s.strike,
                type: s.type,
                results: calculateStrikePnL(spots, s.strike, timeInYears, sigma, s.type)
            }));

            // Display results
            displayResults(allResults, strikes);
        }

        /**
         * Display results
         */
        function displayResults(allResults, strikes) {
            // Display calculated strikes with actual deltas
            let strikesHTML = '<div class="verification"><strong>Calculated Strikes (with t=0 Delta):</strong><br>';
            allResults.forEach((r, idx) => {
                const initialDelta = r.results[0].delta;
                strikesHTML += `${r.name}: Strike = ${formatNumber(r.strike)}, Δ = ${formatNumber(initialDelta, 3)}`;
                if (idx < allResults.length - 1) strikesHTML += ' | ';
            });
            strikesHTML += '<br><strong>Verification:</strong> Strikes should be ordered: 10Δ Put &lt; 25Δ Put &lt; ATM &lt; 25Δ Call &lt; 10Δ Call</div>';
            document.getElementById('strikes-info').innerHTML = strikesHTML;

            // Create summary table
            let summaryHTML = '<h2>Summary - Final P&L Across All Strikes</h2>';
            summaryHTML += '<table class="summary-table"><thead><tr>';
            summaryHTML += '<th>Strike Type</th><th>Strike Price</th><th>Final Portfolio P&L</th></tr></thead><tbody>';

            let totalPnL = 0;
            allResults.forEach(r => {
                const finalPnL = r.results[r.results.length - 1].portfolioValue;
                totalPnL += finalPnL;
                summaryHTML += `<tr><td>${r.name}</td><td>${formatNumber(r.strike)}</td><td>${formatThousand(finalPnL)}</td></tr>`;
            });

            summaryHTML += `<tr><td colspan="2"><strong>TOTAL</strong></td><td><strong>${formatThousand(totalPnL)}</strong></td></tr>`;
            summaryHTML += '</tbody></table>';

            document.getElementById('summary').innerHTML = summaryHTML;

            // Create individual tables for each strike
            let resultsHTML = '';

            allResults.forEach(strikeData => {
                resultsHTML += `<div class="strike-section">`;
                resultsHTML += `<div class="strike-header">Strike: ${formatNumber(strikeData.strike)} (${strikeData.name})</div>`;

                // Verification at t=0
                const t0Portfolio = strikeData.results[0].portfolioValue;
                const isValid = Math.abs(t0Portfolio) < 1;
                resultsHTML += `<div class="verification ${isValid ? '' : 'warning'}" style="font-size: 11px; padding: 8px;">`;
                resultsHTML += `<strong>t=0 Verification:</strong> Portfolio = ${formatThousand(t0Portfolio)} `;
                resultsHTML += isValid ? '✓' : '✗ ERROR';
                resultsHTML += '</div>';

                // Table
                resultsHTML += '<table class="strike-table"><thead><tr>';
                resultsHTML += '<th>Time (h)</th><th>Spot</th><th>Delta</th>';
                resultsHTML += '<th>Incr Hedge</th><th>Cum Hedge</th><th>Avg Spot</th>';
                resultsHTML += '<th>Hedge P&L</th><th>Option Value</th><th>Premium</th><th>Portfolio Value</th>';
                resultsHTML += '</tr></thead><tbody>';

                strikeData.results.forEach(r => {
                    resultsHTML += '<tr>';
                    resultsHTML += `<td>${r.time}</td>`;
                    resultsHTML += `<td>${formatNumber(r.spot)}</td>`;
                    resultsHTML += `<td>${formatNumber(r.delta, 3)}</td>`;
                    resultsHTML += `<td>${formatMillion(r.incrementalHedge)}</td>`;
                    resultsHTML += `<td>${formatMillion(r.cumulativeHedge)}</td>`;
                    resultsHTML += `<td>${r.avgSpot !== 0 ? formatNumber(r.avgSpot) : '-'}</td>`;
                    resultsHTML += `<td>${formatThousand(r.hedgePnL)}</td>`;
                    resultsHTML += `<td>${formatThousand(r.optionValue)}</td>`;
                    resultsHTML += `<td>${formatThousand(r.premium)}</td>`;
                    resultsHTML += `<td>${formatThousand(r.portfolioValue)}</td>`;
                    resultsHTML += '</tr>';
                });

                resultsHTML += '</tbody></table></div>';
            });

            document.getElementById('results').innerHTML = resultsHTML;
        }

        // Calculate on page load
        window.onload = calculate;
    </script>
</body>
</html>
