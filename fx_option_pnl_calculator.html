<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FX Option P&L Calculator - 10-Minute Intervals</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1600px;
            margin: 20px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        h2 {
            color: #555;
            margin-top: 30px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
        }
        .input-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .input-group {
            display: flex;
            flex-direction: column;
        }
        .input-group-full {
            grid-column: 1 / -1;
        }
        label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #555;
        }
        input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        textarea {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            resize: vertical;
        }
        button {
            background-color: #007bff;
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
            margin-right: 10px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button.secondary {
            background-color: #6c757d;
        }
        button.secondary:hover {
            background-color: #545b62;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 11px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 6px 4px;
            text-align: right;
        }
        th {
            background-color: #007bff;
            color: white;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .summary-table tr:first-child {
            background-color: #fff;
        }
        .summary-table tbody tr:last-child {
            background-color: #d4edda;
            font-weight: bold;
        }
        .strike-table-wrapper {
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .strike-table tbody tr:first-child {
            background-color: #fff3cd;
        }
        .strike-table tbody tr:last-child {
            background-color: #d4edda;
            font-weight: bold;
        }
        .verification {
            margin-top: 20px;
            padding: 15px;
            background-color: #d4edda;
            border-left: 4px solid #28a745;
            border-radius: 4px;
            font-size: 13px;
        }
        .warning {
            background-color: #fff3cd;
            border-left-color: #ffc107;
        }
        .error {
            background-color: #f8d7da;
            border-left-color: #dc3545;
        }
        .info-box {
            background-color: #e7f3ff;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            border-left: 4px solid #007bff;
        }
        .strike-section {
            margin-top: 30px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
        .strike-header {
            font-size: 16px;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>FX Option P&L Calculator - 10-Minute Intervals</h1>

        <div class="info-box">
            <strong>Configuration:</strong> EURUSD Options (5 strikes), Notional: 100M Settlement Currency (USD) per strike
            <br><strong>Note:</strong> Base currency (EUR) notional varies by strike: Base Notional = 100M / Strike
            <br><strong>Time Period:</strong> 24 hours (1440 minutes) with 10-minute intervals = 145 data points
            <br><strong>Model:</strong> Black-Scholes with r=0, q=0
            <br><strong>Strikes:</strong> 10Δ Put, 25Δ Put, ATM Call, 25Δ Call, 10Δ Call
        </div>

        <div class="input-section">
            <div class="input-group">
                <label>Initial Spot (for test data generation):</label>
                <input type="number" id="initialSpot" step="0.0001" value="1.1000">
            </div>
            <div class="input-group">
                <label>Implied Volatility (%):</label>
                <input type="number" id="vol" step="0.1" value="10">
            </div>
        </div>

        <div class="input-section">
            <div class="input-group input-group-full">
                <label>Spot Price Series (145 values, one per line, starting at t=0 minutes):</label>
                <textarea id="spotSeries" rows="10" placeholder="Paste 145 spot prices here, one per line..."></textarea>
                <div style="margin-top: 5px;">
                    <button class="secondary" onclick="generateTestData()">Generate Test Data</button>
                    <button onclick="calculate()">Calculate All Strikes</button>
                </div>
            </div>
        </div>

        <div id="validation-message"></div>
        <div id="strikes-info"></div>
        <div id="summary"></div>
        <div id="results"></div>
    </div>

    <script>
        // Constants
        const SETTLEMENT_NOTIONAL = 100_000_000; // 100 million USD (settlement currency)
        const MINUTES_IN_DAY = 1440;
        const NUM_POINTS = 145; // 0, 10, 20, ..., 1440
        const INTERVAL_MINUTES = 10;

        // ============ STRIKE CALCULATION - EXACT CODE ============

        function erf(x) {
            const sign = x >= 0 ? 1 : -1;
            x = Math.abs(x);
            const a1 = 0.254829592;
            const a2 = -0.284496736;
            const a3 = 1.421413741;
            const a4 = -1.453152027;
            const a5 = 1.061405429;
            const p = 0.3275911;
            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            return sign * y;
        }

        function normalCDF(x) {
            return 0.5 * (1 + erf(x / Math.sqrt(2)));
        }

        function inverseNormalCDF(p) {
            if (p <= 0 || p >= 1) throw new Error('p must be between 0 and 1');

            const a = [
                -3.969683028665376e+01, 2.209460984245205e+02,
                -2.759285104469687e+02, 1.383577518672690e+02,
                -3.066479806614716e+01, 2.506628277459239e+00
            ];
            const b = [
                -5.447609879822406e+01, 1.615858368580409e+02,
                -1.556989798598866e+02, 6.680131188771972e+01,
                -1.328068155288572e+01
            ];
            const c = [
                -7.784894002430293e-03, -3.223964580411365e-01,
                -2.400758277161838e+00, -2.549732539343734e+00,
                4.374664141464968e+00, 2.938163982698783e+00
            ];
            const d = [
                7.784695709041462e-03, 3.224671290700398e-01,
                2.445134137142996e+00, 3.754408661907416e+00
            ];

            const pLow = 0.02425;
            const pHigh = 1 - pLow;

            let q, r, result;

            if (p < pLow) {
                q = Math.sqrt(-2 * Math.log(p));
                result = (((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) /
                         ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);
            } else if (p <= pHigh) {
                q = p - 0.5;
                r = q * q;
                result = (((((a[0] * r + a[1]) * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * q /
                         (((((b[0] * r + b[1]) * r + b[2]) * r + b[3]) * r + b[4]) * r + 1);
            } else {
                q = Math.sqrt(-2 * Math.log(1 - p));
                result = -(((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) /
                          ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);
            }

            return result;
        }

        function calculateStrikeFromDelta(spot, annualVol, timeYears, targetDelta) {
            const volSqrtT = annualVol * Math.sqrt(timeYears);
            const varianceAdj = 0.5 * annualVol * annualVol * timeYears;
            const d1Input = (targetDelta < 0) ? (targetDelta + 1.0) : targetDelta;
            const d1 = inverseNormalCDF(d1Input);
            const logMoneyness = d1 * volSqrtT - varianceAdj;
            const strike = spot * Math.exp(-logMoneyness);
            return strike;
        }

        // ============ END STRIKE CALCULATION CODE ============

        function normCDF(x) {
            return normalCDF(x);
        }

        function blackScholesCall(S, K, T, sigma) {
            if (T <= 0) {
                return Math.max(S - K, 0);
            }

            const sqrtT = Math.sqrt(T);
            const d1 = (Math.log(S / K) + (0.5 * sigma * sigma * T)) / (sigma * sqrtT);
            const d2 = d1 - sigma * sqrtT;

            return S * normCDF(d1) - K * normCDF(d2);
        }

        function blackScholesPut(S, K, T, sigma) {
            if (T <= 0) {
                return Math.max(K - S, 0);
            }

            const sqrtT = Math.sqrt(T);
            const d1 = (Math.log(S / K) + (0.5 * sigma * sigma * T)) / (sigma * sqrtT);
            const d2 = d1 - sigma * sqrtT;

            return K * normCDF(-d2) - S * normCDF(-d1);
        }

        function callDelta(S, K, T, sigma) {
            if (T <= 0) {
                return S > K ? 1 : 0;
            }

            const sqrtT = Math.sqrt(T);
            const d1 = (Math.log(S / K) + (0.5 * sigma * sigma * T)) / (sigma * sqrtT);

            return normCDF(d1);
        }

        function putDelta(S, K, T, sigma) {
            return callDelta(S, K, T, sigma) - 1;
        }

        function formatThousand(value) {
            const thousands = value / 1_000;
            const absThousands = Math.abs(thousands);
            const sign = thousands < 0 ? '-' : '';
            const formatted = absThousands.toFixed(1).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            return sign + formatted + 'k';
        }

        function formatMillion(value) {
            const millions = value / 1_000_000;
            const absMillion = Math.abs(millions);
            const sign = millions < 0 ? '-' : '';
            const formatted = absMillion.toFixed(1);
            return sign + formatted + 'm';
        }

        function formatNumber(value, decimals = 4) {
            return value.toFixed(decimals);
        }

        function generateTestData() {
            const initialSpot = parseFloat(document.getElementById('initialSpot').value);
            if (isNaN(initialSpot) || initialSpot <= 0) {
                showValidationMessage('Please enter a valid initial spot price', 'error');
                return;
            }

            const spots = [initialSpot];
            let currentSpot = initialSpot;

            // Generate 144 more values with random walk
            for (let i = 1; i < NUM_POINTS; i++) {
                // Random move: ±0.01% to ±0.05% per 10 minutes
                const randomMove = (Math.random() - 0.5) * 0.0008 * currentSpot;
                currentSpot = currentSpot + randomMove;
                spots.push(currentSpot);
            }

            // Fill textarea
            document.getElementById('spotSeries').value = spots.map(s => s.toFixed(4)).join('\n');
            showValidationMessage('Test data generated successfully (145 values)', 'verification');
        }

        function showValidationMessage(message, type = 'verification') {
            const div = document.getElementById('validation-message');
            div.innerHTML = `<div class="${type}">${message}</div>`;
        }

        function parseSpotSeries() {
            const text = document.getElementById('spotSeries').value.trim();
            if (!text) {
                showValidationMessage('Please enter spot price series', 'error');
                return null;
            }

            const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);

            if (lines.length !== NUM_POINTS) {
                showValidationMessage(`Error: Expected ${NUM_POINTS} values, got ${lines.length}`, 'error');
                return null;
            }

            const spots = [];
            for (let i = 0; i < lines.length; i++) {
                const value = parseFloat(lines[i]);
                if (isNaN(value) || value <= 0) {
                    showValidationMessage(`Error: Invalid value at line ${i + 1}: "${lines[i]}"`, 'error');
                    return null;
                }
                spots.push(value);
            }

            return spots;
        }

        function calculateStrikePnL(spots, strike, sigma, optionType, baseNotional) {
            let results = [];
            let cumulativeHedge = 0;
            let weightedSumHedge = 0;
            let avgSpot = 0;
            let realizedPnL = 0;
            let previousDelta = 0;

            // Calculate premium at t=0
            const T0 = 1 / 365; // 1 day in years
            const premium = optionType === 'call'
                ? blackScholesCall(spots[0], strike, T0, sigma)
                : blackScholesPut(spots[0], strike, T0, sigma);
            const premiumPaid = -premium * baseNotional;

            for (let i = 0; i < NUM_POINTS; i++) {
                const timeMinutes = i * INTERVAL_MINUTES;
                const spot = spots[i];

                // Time remaining in years
                const minutesRemaining = MINUTES_IN_DAY - timeMinutes;
                const daysRemaining = minutesRemaining / MINUTES_IN_DAY;
                const T = daysRemaining / 365;

                // Calculate option value and delta
                const optionValue = optionType === 'call'
                    ? blackScholesCall(spot, strike, T, sigma)
                    : blackScholesPut(spot, strike, T, sigma);

                const delta = optionType === 'call'
                    ? callDelta(spot, strike, T, sigma)
                    : putDelta(spot, strike, T, sigma);

                // Calculate incremental hedge
                let incrementalHedge;
                if (i === 0) {
                    incrementalHedge = -delta * baseNotional;
                } else {
                    const deltaChange = delta - previousDelta;
                    incrementalHedge = -deltaChange * baseNotional;
                }

                // Update cumulative hedge with realized/unrealized P&L tracking
                const prevCumHedge = cumulativeHedge;
                const prevAvgSpot = avgSpot;
                const newCumHedge = prevCumHedge + incrementalHedge;

                if (prevCumHedge === 0) {
                    cumulativeHedge = newCumHedge;
                    weightedSumHedge = newCumHedge * spot;
                    avgSpot = spot;
                } else if (newCumHedge === 0) {
                    realizedPnL += prevCumHedge * (spot - prevAvgSpot);
                    cumulativeHedge = 0;
                    weightedSumHedge = 0;
                    avgSpot = 0;
                } else if (Math.sign(prevCumHedge) !== Math.sign(newCumHedge)) {
                    realizedPnL += prevCumHedge * (spot - prevAvgSpot);
                    cumulativeHedge = newCumHedge;
                    weightedSumHedge = newCumHedge * spot;
                    avgSpot = spot;
                } else if (Math.abs(newCumHedge) < Math.abs(prevCumHedge)) {
                    const closedAmount = prevCumHedge - newCumHedge;
                    realizedPnL += closedAmount * (spot - prevAvgSpot);
                    cumulativeHedge = newCumHedge;
                    weightedSumHedge = newCumHedge * prevAvgSpot;
                    avgSpot = prevAvgSpot;
                } else {
                    cumulativeHedge = newCumHedge;
                    weightedSumHedge += incrementalHedge * spot;
                    avgSpot = weightedSumHedge / cumulativeHedge;
                }

                const unrealizedPnL = cumulativeHedge !== 0 ? cumulativeHedge * (spot - avgSpot) : 0;
                const hedgePnL = realizedPnL + unrealizedPnL;
                const portfolioValue = premiumPaid + (optionValue * baseNotional) + hedgePnL;

                results.push({
                    time: timeMinutes,
                    spot: spot,
                    delta: delta,
                    incrementalHedge: incrementalHedge,
                    cumulativeHedge: cumulativeHedge,
                    avgSpot: avgSpot,
                    realizedPnL: realizedPnL,
                    unrealizedPnL: unrealizedPnL,
                    hedgePnL: hedgePnL,
                    optionValue: optionValue * baseNotional,
                    premium: premiumPaid,
                    portfolioValue: portfolioValue
                });

                previousDelta = delta;
            }

            return results;
        }

        function calculate() {
            console.log("=== CALCULATION START ===");

            // Parse and validate spot series
            console.log("Parsing spot series...");
            const spots = parseSpotSeries();
            if (!spots) {
                console.log("Spot parsing failed, aborting");
                return;
            }
            console.log("Spots parsed successfully:", spots.length, "values");
            console.log("First spot:", spots[0], "Last spot:", spots[spots.length - 1]);

            showValidationMessage(`✓ Validated ${NUM_POINTS} spot prices`, 'verification');

            const volPercent = parseFloat(document.getElementById('vol').value);
            const sigma = volPercent / 100;
            console.log("Volatility:", volPercent + "%", "Sigma:", sigma);

            // Calculate strikes
            const S0 = spots[0];
            const T0 = 1 / 365; // 1 day
            console.log("Initial spot (S0):", S0, "Time (T0):", T0);

            console.log("Calculating strikes...");
            const strikes = [
                { name: '10Δ Put', strike: calculateStrikeFromDelta(S0, sigma, T0, -0.10), type: 'put' },
                { name: '25Δ Put', strike: calculateStrikeFromDelta(S0, sigma, T0, -0.25), type: 'put' },
                { name: 'ATM Call', strike: S0, type: 'call' },
                { name: '25Δ Call', strike: calculateStrikeFromDelta(S0, sigma, T0, 0.25), type: 'call' },
                { name: '10Δ Call', strike: calculateStrikeFromDelta(S0, sigma, T0, 0.10), type: 'call' }
            ];
            console.log("Strikes calculated:", strikes.map(s => `${s.name}: ${s.strike.toFixed(4)}`).join(', '));

            // Calculate P&L for each strike with base notional = 100M / strike
            console.log("Starting P&L calculations for all strikes...");
            const allResults = strikes.map((s, idx) => {
                console.log(`Calculating strike ${idx + 1}/5: ${s.name} (${s.strike.toFixed(4)})`);
                const baseNotional = SETTLEMENT_NOTIONAL / s.strike;
                console.log(`  Base notional: ${(baseNotional / 1_000_000).toFixed(1)}M`);

                const result = {
                    name: s.name,
                    strike: s.strike,
                    type: s.type,
                    baseNotional: baseNotional,
                    results: calculateStrikePnL(spots, s.strike, sigma, s.type, baseNotional)
                };
                console.log(`  Calculated ${result.results.length} time points`);
                return result;
            });
            console.log("P&L calculations complete for all strikes");

            console.log("Calling displayResults...");
            try {
                displayResults(allResults, strikes);
            } catch (error) {
                console.error("ERROR in displayResults:", error);
                console.error("Stack trace:", error.stack);
            }
            console.log("=== CALCULATION END ===");
        }

        function displayResults(allResults, strikes) {
            console.log("=== DISPLAY RESULTS START ===");
            console.log("allResults:", allResults.length, "strikes");

            // Diagnostic check
            if (!allResults || allResults.length === 0) {
                console.error("ERROR: No results to display!");
                return;
            }

            // Check DOM elements exist
            const strikesInfoDiv = document.getElementById('strikes-info');
            const summaryDiv = document.getElementById('summary');
            const resultsDiv = document.getElementById('results');

            console.log("DOM elements:", {
                'strikes-info': !!strikesInfoDiv,
                'summary': !!summaryDiv,
                'results': !!resultsDiv
            });

            if (!strikesInfoDiv || !summaryDiv || !resultsDiv) {
                console.error("ERROR: Required DOM elements not found!");
                return;
            }

            // Display calculated strikes
            console.log("Building strikes HTML...");
            let strikesHTML = '<div class="verification"><strong>Calculated Strikes (with t=0 Delta):</strong><br>';
            allResults.forEach((r, idx) => {
                const initialDelta = r.results[0].delta;
                strikesHTML += `${r.name}: Strike = ${formatNumber(r.strike)}, Δ = ${formatNumber(initialDelta, 3)}`;
                if (idx < allResults.length - 1) strikesHTML += ' | ';
            });
            strikesHTML += '<br><strong>Verification:</strong> Strikes ordered: 10Δ Put &lt; 25Δ Put &lt; ATM &lt; 25Δ Call &lt; 10Δ Call</div>';
            strikesInfoDiv.innerHTML = strikesHTML;
            console.log("Strikes HTML updated");

            // Create summary table
            console.log("Building summary table...");
            let summaryHTML = '<h2>Summary - Final P&L Across All Strikes (100M Settlement Currency)</h2>';
            summaryHTML += '<table class="summary-table"><thead><tr>';
            summaryHTML += '<th>Strike Type</th><th>Strike Price</th><th>Base Notional</th><th>Final Portfolio P&L</th></tr></thead><tbody>';

            let totalPnL = 0;
            allResults.forEach(r => {
                const finalPnL = r.results[r.results.length - 1].portfolioValue;
                totalPnL += finalPnL;
                summaryHTML += `<tr><td>${r.name}</td><td>${formatNumber(r.strike)}</td><td>${formatMillion(r.baseNotional)} EUR</td><td>${formatThousand(finalPnL)}</td></tr>`;
            });

            summaryHTML += `<tr><td colspan="3"><strong>TOTAL</strong></td><td><strong>${formatThousand(totalPnL)}</strong></td></tr>`;
            summaryHTML += '</tbody></table>';

            summaryDiv.innerHTML = summaryHTML;
            console.log("Summary table HTML set successfully");

            // Create individual tables for each strike
            console.log("Building individual strike tables...");
            let resultsHTML = '';

            allResults.forEach((strikeData, idx) => {
                console.log(`  Building table for strike ${idx + 1}: ${strikeData.name}`);
                resultsHTML += `<div class="strike-section">`;
                resultsHTML += `<div class="strike-header">Strike: ${formatNumber(strikeData.strike)} (${strikeData.name}) - All ${NUM_POINTS} Time Points</div>`;

                // Verification at t=0
                const t0Portfolio = strikeData.results[0].portfolioValue;
                const isValid = Math.abs(t0Portfolio) < 1;
                resultsHTML += `<div class="verification ${isValid ? '' : 'warning'}" style="font-size: 11px; padding: 8px;">`;
                resultsHTML += `<strong>t=0 Verification:</strong> Portfolio = ${formatThousand(t0Portfolio)} `;
                resultsHTML += isValid ? '✓' : '✗ ERROR';
                resultsHTML += '</div>';

                // Table wrapper for scrolling
                resultsHTML += '<div class="strike-table-wrapper">';
                resultsHTML += '<table class="strike-table"><thead><tr>';
                resultsHTML += '<th>Time (min)</th><th>Spot</th><th>Delta</th>';
                resultsHTML += '<th>Incr Hedge (m)</th><th>Cum Hedge (m)</th><th>Avg Spot</th>';
                resultsHTML += '<th>Hedge P&L (k)</th><th>Option Value (k)</th><th>Premium (k)</th><th>Portfolio Value (k)</th>';
                resultsHTML += '</tr></thead><tbody>';

                strikeData.results.forEach(r => {
                    resultsHTML += '<tr>';
                    resultsHTML += `<td>${r.time}</td>`;
                    resultsHTML += `<td>${formatNumber(r.spot)}</td>`;
                    resultsHTML += `<td>${formatNumber(r.delta, 3)}</td>`;
                    resultsHTML += `<td>${formatMillion(r.incrementalHedge)}</td>`;
                    resultsHTML += `<td>${formatMillion(r.cumulativeHedge)}</td>`;
                    resultsHTML += `<td>${r.avgSpot !== 0 ? formatNumber(r.avgSpot) : '-'}</td>`;
                    resultsHTML += `<td>${formatThousand(r.hedgePnL)}</td>`;
                    resultsHTML += `<td>${formatThousand(r.optionValue)}</td>`;
                    resultsHTML += `<td>${formatThousand(r.premium)}</td>`;
                    resultsHTML += `<td>${formatThousand(r.portfolioValue)}</td>`;
                    resultsHTML += '</tr>';
                });

                resultsHTML += '</tbody></table></div></div>';
            });

            console.log("Setting results HTML...");
            resultsDiv.innerHTML = resultsHTML;
            console.log("Results HTML set successfully");
            console.log("=== DISPLAY RESULTS COMPLETE ===");
        }

        // No auto-calculate on load - wait for user input
    </script>
</body>
</html>
